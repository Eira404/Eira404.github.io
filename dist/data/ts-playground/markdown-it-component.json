[
  {
    "name": "component.ts",
    "code": "import type MarkdownIt from 'markdown-it'\r\nimport type Token from 'markdown-it/lib/token.mjs'\r\nimport type Renderer from 'markdown-it/lib/renderer.mjs'\r\nimport type { Options } from 'markdown-it'\r\nimport type StateBlock from 'markdown-it/lib/rules_block/state_block.mjs'\r\n\r\ntype ConfigKey = string | string[]\r\n\r\ntype ConfigsDict = {\r\n  [property: string]: string | string[]\r\n}\r\n\r\nexport interface ComponentPluginOptions {\r\n  init?: (options: ComponentPluginOptions) => void\r\n  markerBegin?: string\r\n  markerEnd?: string\r\n  dataDivision?: string\r\n  configDivision?: string\r\n  useEqual?: boolean\r\n  useIndex?: boolean\r\n  configKeys?: ConfigKey[]\r\n  render?: (tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) => string\r\n  renderDivision?: (\r\n    tokens: Token[],\r\n    idx: number,\r\n    _options: Options,\r\n    env: any,\r\n    slf: Renderer\r\n  ) => string\r\n}\r\n\r\ntype FindStartRes =\r\n  | {\r\n      check: false\r\n    }\r\n  | {\r\n      check: true\r\n      name: boolean\r\n      pos?: number\r\n    }\r\n\r\ntype FindEndRes =\r\n  | {\r\n      check: false\r\n    }\r\n  | {\r\n      check: true\r\n      pos: number\r\n    }\r\n\r\ntype FindDataDRes =\r\n  | {\r\n      check: false\r\n    }\r\n  | {\r\n      check: true\r\n      pos: number\r\n    }\r\n\r\ntype AnsDataRes =\r\n  | {\r\n      check: false\r\n    }\r\n  | {\r\n      check: true\r\n      silent: true\r\n    }\r\n  | {\r\n      check: true\r\n      silent?: true\r\n      configList: string[]\r\n      dataList: Array<{ lineBegin: number; lineEnd: number }>\r\n      markerBeginData: {\r\n        markup: string\r\n        pos: number\r\n        line: number\r\n      }\r\n      markerEndData: {\r\n        markup: string\r\n        line: number\r\n      }\r\n    }\r\n\r\nexport default function componentPlugin(\r\n  md: MarkdownIt,\r\n  name: string | string[],\r\n  options?: ComponentPluginOptions\r\n) {\r\n  if (typeof name !== 'string' || name === '') return\r\n\r\n  const defaultName = Array.isArray(name) ? name[0] : name\r\n  const namesSet = new Set(Array.isArray(name) ? name : [name])\r\n\r\n  function renderDefault(tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) {\r\n    //\r\n    // add a class to the opening tag\r\n    //\r\n    if (tokens[idx].nesting === 1) {\r\n      tokens[idx].attrJoin('class', defaultName)\r\n    }\r\n    return slf.renderToken(tokens, idx, _options)\r\n  }\r\n\r\n  function renderDivisionDefault(\r\n    tokens: Token[],\r\n    idx: number,\r\n    _options: Options,\r\n    env: any,\r\n    slf: Renderer\r\n  ) {\r\n    return slf.renderToken(tokens, idx, _options)\r\n  }\r\n\r\n  options = options || {}\r\n\r\n  const markerBegin = options.markerBegin || '{|'\r\n  const markerEnd = options.markerEnd || '|}'\r\n  const dataDivision = options.dataDivision || '|-'\r\n  const configDivision = options.configDivision || '|'\r\n  //\r\n  // 为true则支持语法：config1 = xxx\r\n  //\r\n  const useEqual = options.useEqual || true\r\n  //\r\n  // 0 = xxx\r\n  // xxx\r\n  // ->\r\n  // 0: xxx\r\n  //\r\n  const useIndex = options.useIndex || false\r\n  //\r\n  // config keys\r\n  // 设置这个才能更好的使用 0=xxx\r\n  // 例如: 设置[\"color\"];md中写0=red\r\n  // 获得: { \"color\": \"red\" }\r\n  // 否则获得: { \"0\": \"red\" }\r\n  //\r\n  const configKeys = options.configKeys || []\r\n  //\r\n  // 配置映射关系\r\n  //\r\n  const confMap = buildConfMap(configKeys)\r\n\r\n  const render = options.render || renderDefault\r\n\r\n  const renderDivision = options.renderDivision || renderDivisionDefault\r\n\r\n  if (options.init instanceof Function) options.init(options)\r\n\r\n  function buildConfMap(configKeys: ConfigKey[]) {\r\n    const map = new Map<string, string>()\r\n    configKeys.forEach((conf) => {\r\n      if (Array.isArray(conf)) {\r\n        const base = conf[0]\r\n        conf.forEach((c) => {\r\n          map.set(base, c)\r\n        })\r\n      } else {\r\n        map.set(conf, conf)\r\n      }\r\n    })\r\n    return map\r\n  }\r\n\r\n  function isComponentBegin(state: StateBlock, start: number): FindStartRes {\r\n    // 在行内寻找 markerBegin\r\n    // markerBegin 必须是一行起始\r\n    //\r\n    const l = markerBegin.length\r\n    // 检查是否是以 markerBegin 起始\r\n    //\r\n    if (markerBegin !== state.src.slice(start, start + l)) {\r\n      return {\r\n        check: false\r\n      }\r\n    }\r\n\r\n    // 以 markerBegin 起始\r\n    // 检查后面是否跟着 自己的name\r\n    //\r\n    const p = state.src.indexOf(configDivision, start + l)\r\n    // console.log('configDivision', state.src, configDivision, p)\r\n    const n = state.src.slice(start + l, p).trim()\r\n    // console.log('n', n, namesSet)\r\n    if (!namesSet.has(n)) {\r\n      return {\r\n        check: true,\r\n        name: false\r\n      }\r\n    }\r\n\r\n    return {\r\n      check: true,\r\n      name: true,\r\n      pos: start + l + name.length\r\n    }\r\n  }\r\n\r\n  function isComponentEnd(state: StateBlock, start: number): FindEndRes {\r\n    // 在行内寻找 markerEnd\r\n    // markerEnd 必须是一行起始\r\n    // markerEnd 后面内容无效\r\n    //\r\n\r\n    // 检查是否是以 markerEnd 起始\r\n    //\r\n    if (markerEnd !== state.src.slice(start, start + markerEnd.length)) {\r\n      return {\r\n        check: false\r\n      }\r\n    }\r\n\r\n    return {\r\n      check: true,\r\n      pos: start\r\n    }\r\n  }\r\n\r\n  function isDataDivision(state: StateBlock, start: number): FindDataDRes {\r\n    // 在行内寻找 dataDivision\r\n    // dataDivision 必须是一行起始\r\n    // dataDivision 后面内容无效\r\n    //\r\n\r\n    // 检查是否是以 dataDivision 起始\r\n    //\r\n    if (dataDivision !== state.src.slice(start, start + dataDivision.length)) {\r\n      return {\r\n        check: false\r\n      }\r\n    }\r\n\r\n    return {\r\n      check: true,\r\n      pos: start\r\n    }\r\n  }\r\n\r\n  function analyseData(\r\n    state: StateBlock,\r\n    startLine: number,\r\n    endLine: number,\r\n    silent: boolean\r\n  ): AnsDataRes {\r\n    // 找到一对marker\r\n    // 要考虑到嵌套关系\r\n    //\r\n    let markerLevel = 0\r\n    let line = startLine\r\n    let markerBeginData: any = null\r\n    let markerEndData: any = null\r\n    let lastDataDivisionLine = -1\r\n    const dataList: any[] = []\r\n    let configList: any = null\r\n    for (; line < endLine; line++) {\r\n      const start = state.bMarks[line] + state.tShift[line]\r\n      const max = state.eMarks[line]\r\n      const res1 = isComponentBegin(state, start)\r\n      if (res1.check) {\r\n        if (res1.name) {\r\n          // 匹配到本模板的起始\r\n          // pos不包括前面的内容\r\n          // {|name|xxx|yyy|zzz...\r\n          //       ⬆\r\n          // pos指向'|'\r\n          //\r\n          if (markerBeginData) {\r\n            // 匹配到本模板开始\r\n            // 但已经存在本模板\r\n            // 为嵌套\r\n            //\r\n            markerLevel++\r\n          } else {\r\n            // 匹配到本模板开始\r\n            //\r\n            markerBeginData = {\r\n              markup: markerBegin,\r\n              pos: res1.pos as number,\r\n              line: line\r\n            }\r\n\r\n            // Since start is found, we can report success here in validation mode\r\n            //\r\n            if (silent) {\r\n              return {\r\n                check: true,\r\n                silent: true\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          // 匹配到模板开始，但是不是本模板\r\n          //\r\n          markerLevel++\r\n        }\r\n      } else {\r\n        if (markerBeginData === null) {\r\n          // 第一次就匹配失败\r\n          // 不是本组件\r\n          //\r\n          return {\r\n            check: false\r\n          }\r\n        }\r\n        // 没有匹配到模板开始\r\n        // 检查模板结束\r\n        const res2 = isComponentEnd(state, start)\r\n        if (res2.check) {\r\n          if (markerLevel === 0) {\r\n            markerEndData = {\r\n              markup: markerEnd,\r\n              line: line\r\n            }\r\n            // 匹配结束\r\n            //\r\n            if (lastDataDivisionLine !== -1) {\r\n              dataList.push({\r\n                lineBegin: lastDataDivisionLine + 1,\r\n                lineEnd: line\r\n              })\r\n            }\r\n            return {\r\n              configList: configList || [],\r\n              dataList,\r\n              check: true,\r\n              markerBeginData,\r\n              markerEndData\r\n            }\r\n          } else {\r\n            // 退出上层模板\r\n            //\r\n            markerLevel--\r\n          }\r\n        } else {\r\n          // 也没有匹配到模板结束\r\n          // 检查模板数据分隔符\r\n          //\r\n          const res3 = isDataDivision(state, start)\r\n          if (res3.check && markerLevel === 0) {\r\n            // 匹配到数据分隔符 且 是本组件的数据分割符\r\n            //\r\n            if (configList === null) {\r\n              // 还没有进行config设置\r\n              //\r\n              const configStr = state.src.slice(markerBeginData.pos, res3.pos)\r\n              configList = configStr\r\n                .split(configDivision)\r\n                .map((conf) => conf.trim())\r\n                .filter((conf) => conf !== '')\r\n              lastDataDivisionLine = line\r\n            } else {\r\n              // 已经进行config设置\r\n              //\r\n              if (line - lastDataDivisionLine <= 1) {\r\n                // 两个dataDivision没有间隔\r\n                // 无法获取data数据\r\n                // 跳过\r\n                //\r\n              } else {\r\n                // 存入data\r\n                // 闭 - 开\r\n                //\r\n                dataList.push({\r\n                  lineBegin: lastDataDivisionLine + 1,\r\n                  lineEnd: line\r\n                })\r\n              }\r\n              // 更新\r\n              //\r\n              lastDataDivisionLine = line\r\n            }\r\n          } else {\r\n            // 啥也没匹配到\r\n            //\r\n            continue\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      check: false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析配置项\r\n   * @param config\r\n   * @param configs\r\n   * @param i\r\n   * @returns\r\n   */\r\n  function analyseConfig(config: string, configs: ConfigsDict, i: number) {\r\n    const equalRegexp = /(?<!\\\\)=/g\r\n    const commaRegexp = /(?<!\\\\),/g\r\n\r\n    const equalRes = equalRegexp.exec(config)\r\n    equalRegexp.lastIndex = 0\r\n    const equalIndex = equalRes === null ? -1 : equalRes.index\r\n    const key = equalIndex === -1 ? i.toString() : config.slice(0, equalIndex).trim()\r\n    const value_ = equalIndex === -1 ? config : config.slice(equalIndex + 1).trim()\r\n    const value: any = []\r\n    let commaRes = commaRegexp.exec(value_)\r\n    let from = 0\r\n    while (commaRes !== null) {\r\n      value.push(value_.slice(from, commaRes.index).trim())\r\n      from = commaRes.index + 1\r\n      commaRes = commaRegexp.exec(value_)\r\n    }\r\n    value.push(value_.slice(from).trim())\r\n    commaRegexp.lastIndex = 0\r\n    //\r\n    // 允许使用=语法，且获取到=，且不是0=xxx的情况\r\n    //\r\n    if (useEqual && equalIndex !== -1 && Number.isNaN(Number(key))) {\r\n      //\r\n      // 找到该conf对应的conf\r\n      //\r\n      const trueKey = confMap.get(key)\r\n      if (trueKey === undefined) {\r\n        //\r\n        // 匹配失败不生效\r\n        //\r\n        return\r\n      } else {\r\n        configs[trueKey] = value\r\n        return\r\n      }\r\n    }\r\n    //\r\n    // 允许使用0=和直接下标映射语法，且key是数字\r\n    //\r\n    if (useIndex && !Number.isNaN(Number(key))) {\r\n      const index = Number(key)\r\n      if (configKeys[index] !== undefined) {\r\n        if (Array.isArray(configKeys[index])) {\r\n          configs[configKeys[index][0]] = value\r\n        } else {\r\n          configs[configKeys[index]] = value\r\n        }\r\n      } else {\r\n        configs[key] = value\r\n      }\r\n      return\r\n    }\r\n  }\r\n\r\n  function analyseConfigList(configList: string[]) {\r\n    const configs = {}\r\n    configList.forEach((config, i) => {\r\n      analyseConfig(config, configs, i)\r\n    })\r\n    return configs\r\n  }\r\n\r\n  function component(state: StateBlock, startLine: number, endLine: number, silent: boolean) {\r\n    const res = analyseData(state, startLine, endLine, silent)\r\n    if (!res.check) return false\r\n    if (res.silent !== undefined) return true\r\n\r\n    const oldParent = state.parentType\r\n    const oldLineMax = state.lineMax\r\n    state.parentType = 'blockquote'\r\n\r\n    // this will prevent lazy continuations from ever going past our end marker\r\n    state.lineMax = res.markerEndData.line\r\n\r\n    const token_o = state.push('component_' + name + '_open', 'div', 1)\r\n    token_o.markup = markerBegin\r\n    token_o.block = true\r\n    token_o.meta = {\r\n      configs: analyseConfigList(res.configList)\r\n    }\r\n    token_o.map = [res.markerBeginData.line, res.markerEndData.line]\r\n\r\n    res.dataList.forEach((data, i) => {\r\n      const start = state.bMarks[data.lineBegin] + state.tShift[data.lineBegin]\r\n      const end = state.bMarks[data.lineEnd] + state.tShift[data.lineEnd]\r\n      const dataSrc = state.src.slice(start, end)\r\n      let res\r\n      // if (dataCheck instanceof Function) {\r\n      //   res = dataCheck(dataSrc, i, {})\r\n      // }\r\n      // res 为false时直接跳过分隔符\r\n      // 但是其内部内容依旧会渲染\r\n      // 感觉res为false的可能性几乎没有\r\n      //\r\n      if (res === false) return\r\n\r\n      if (i > 0) {\r\n        // 添加数据分隔符token\r\n        //\r\n        const token_d = state.push('component_' + name + '_division', 'div', 0)\r\n        token_d.markup = dataDivision\r\n        token_d.meta = {\r\n          index: i\r\n        }\r\n      }\r\n      state.md.block.tokenize(state, data.lineBegin, data.lineEnd)\r\n    })\r\n\r\n    const token_c = state.push('component_' + name + '_close', 'div', -1)\r\n    token_c.markup = markerEnd\r\n    token_c.block = true\r\n\r\n    state.parentType = oldParent\r\n    state.lineMax = oldLineMax\r\n    state.line = res.markerEndData.line + 1\r\n    return true\r\n  }\r\n\r\n  md.block.ruler.before('fence', 'component_' + name, component, {\r\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\r\n  })\r\n  md.renderer.rules['component_' + name + '_open'] = render\r\n  md.renderer.rules['component_' + name + '_close'] = render\r\n  md.renderer.rules['component_' + name + '_division'] = renderDivision\r\n}\r\n"
  },
  {
    "name": "ComponentForTest.ts",
    "code": "import type MarkdownIt from 'markdown-it'\r\nimport type Token from 'markdown-it/lib/token.mjs'\r\nimport componentPlugin from './component.ts'\r\nimport type { ComponentPluginOptions } from './component.ts'\r\nfunction initClassifyComponentPlugin(md: MarkdownIt) {\r\n  md.use(componentPlugin, 'classify', {\r\n    render: function (tokens: Token[], idx: number) {\r\n      const token = tokens[idx]\r\n      if (token.nesting === 1) {\r\n        const name = Math.floor(Math.random() * 1000000).toString()\r\n        const configs = token.meta.configs\r\n        const classifies = configs.classifies || []\r\n        let inputs = ''\r\n        classifies.forEach((c: string, i: number) => {\r\n          const t =\r\n            '<div><label><input type=\"radio\" name=\"' +\r\n            name +\r\n            '\" value=\"' +\r\n            i.toString() +\r\n            '\" hidden ' +\r\n            (i === 0 ? 'checked' : '') +\r\n            '> ' +\r\n            c +\r\n            '</label></div>'\r\n          inputs += t\r\n        })\r\n        // opening tag\r\n        return (\r\n          '<div class=\"markdown-it-component-classify-container\">\\n<div class=\"markdown-it-component-classify\">\\n<div head>\\n' +\r\n          inputs +\r\n          '\\n</div>\\n<div body>\\n<div>\\n'\r\n        )\r\n      } else {\r\n        // closing tag\r\n        return '</div>\\n</div>\\n</div>\\n</div>\\n'\r\n      }\r\n    },\r\n    renderDivision: function (tokens: Token[], idx: number) {\r\n      return '</div>\\n<div>\\n'\r\n    },\r\n    init: function (options: ComponentPluginOptions) {\r\n      const size = 10\r\n      const styleId = 'markdown-it-classify-style'\r\n      let styleBase = `\r\n.markdown-it-component-classify-container {\r\n  border-radius: 8px;\r\n  border: 1px solid var(--bl-color-base-border);\r\n  overflow: hidden;\r\n  margin-bottom: 1rem;\r\n}\r\n.markdown-it-component-classify > div > div {\r\n  position: relative;\r\n}\r\n.markdown-it-component-classify > div[body] > div {\r\n  display: none;\r\n  padding: 0.5rem;\r\n}\r\n.markdown-it-component-classify > div[head] {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  background-color: var(--bl-color-light-fill);\r\n}\r\n.markdown-it-component-classify > div[head] > div > label {\r\n  padding: 0.5rem 1rem;\r\n  cursor: pointer;\r\n  transition: color 0.2s;\r\n  box-sizing: border-box;\r\n  display: block;\r\n  font-weight: bold;\r\n  color: var(--bl-color-secondary-text);\r\n}\r\n.markdown-it-component-classify > div[head] > div:nth-child(n + 2)::before {\r\n  content: '';\r\n  position: absolute;\r\n  top: 50%;\r\n  transform: translateY(-50%) translateX(-50%);\r\n  width: 1px;\r\n  height: 40%;\r\n  background-color: var(--bl-color-primary-text);\r\n}\r\n.markdown-it-component-classify > div[head] > div > label:has(input:checked) {\r\n  transition: color 0.2s;\r\n  color: var(--bl-color-primary-text);\r\n}\r\n.markdown-it-component-classify > div[head] > div > label:hover {\r\n  transition: color 0.2s;\r\n  color: var(--bl-color-primary-text);\r\n}\r\n.markdown-it-component-classify > div[body] > div > *:last-child {\r\n  margin-bottom: 0 !important;\r\n}\r\n\r\n      `\r\n      for (let i = 1; i <= size; i++) {\r\n        if (i > 1) styleBase += ',\\n'\r\n        styleBase += `.markdown-it-component-classify:has( > div[head] > div:nth-child(${i}) > label > input:checked) > div[body] > div:nth-child(${i})`\r\n      }\r\n      styleBase += ` {\r\n  display: block;\r\n}\r\n      `\r\n      if (!document.getElementById(styleId)) {\r\n        const style = document.createElement('style')\r\n        style.setAttribute('id', styleId)\r\n        style.setAttribute('type', 'text/css')\r\n        style.innerHTML = styleBase.trim()\r\n        const head = document.head || document.getElementsByTagName('head')[0]\r\n        head.appendChild(style)\r\n      }\r\n    },\r\n    configKeys: ['classifies']\r\n  })\r\n}\r\n\r\nexport default [initClassifyComponentPlugin]\r\n"
  },
  {
    "name": "index.ts",
    "code": "import ComponentForTest from './ComponentForTest.ts'\r\nimport MarkdownIt from 'markdown-it'\r\n\r\nconst md = new MarkdownIt()\r\n\r\nComponentForTest.forEach(f => {\r\n  md.use(f)\r\n})\r\n\r\nconst doc =\r\n`\r\n{|classify|classifies=中文,English,Français\r\n|-\r\n你好世界！\r\n|-\r\nHello world!\r\n|-\r\nBonjour le monde!\r\n|}\r\n`\r\n\r\nconst res = md.render(doc)\r\n\r\nconsole.log(res)\r\n"
  }
]