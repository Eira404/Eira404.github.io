[
  {
    "name": "index.ts",
    "code": "import TemplateForTest from './TemplateForTest.ts'\r\nimport MarkdownIt from 'markdown-it'\r\n\r\nconst md = new MarkdownIt()\r\n\r\nTemplateForTest.forEach(f => {\r\n  md.use(f)\r\n})\r\n\r\nconst doc =\r\n`\r\n{{template-name-1|warning content|type=warning}}\r\n\r\n{{template-name-1|warning content}}\r\n\r\n{{template-name-2|content|chars=a,b,c,d,e|color=red}}\r\n\r\n{{template-name-3|content|a,b,c,d,e|red}}\r\n\r\n{{template-name-4|chars=a,b,c,d,e|color=red}}\r\n`\r\n\r\nconst res = md.render(doc)\r\n\r\nconsole.log(res)\r\n"
  },
  {
    "name": "template.ts",
    "code": "import type MarkdownIt from 'markdown-it'\r\nimport type Token from 'markdown-it/lib/token.mjs'\r\nimport type Renderer from 'markdown-it/lib/renderer.mjs'\r\nimport type { Options } from 'markdown-it'\r\nimport type StateInline from 'markdown-it/lib/rules_inline/state_inline.mjs'\r\n\r\ntype ConfigKey = string | string[]\r\n\r\nexport interface TemplatePluginOptions {\r\n  tokenizePos?: number[] | boolean\r\n  markerBegin?: string\r\n  markerEnd?: string\r\n  markerDivision?: string\r\n  useEqual?: boolean\r\n  useIndex?: boolean\r\n  configKeys?: ConfigKey[]\r\n  render?: (tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) => string\r\n  renderDivision?: (\r\n    tokens: Token[],\r\n    idx: number,\r\n    _options: Options,\r\n    env: any,\r\n    slf: Renderer\r\n  ) => string\r\n}\r\n\r\ntype DivisionData = {\r\n  begin: number\r\n  end: number\r\n}\r\n\r\ntype FindEndRes = {\r\n  check: boolean\r\n  pos?: number\r\n  divisionDataList?: DivisionData[]\r\n}\r\n\r\ntype ConfigsDict = {\r\n  [property: string]: string | string[]\r\n}\r\n\r\n/**\r\n * ## MD模板\r\n * 默认模板格式如下：`{{name|some words ....|config1|config2=xxx|config3=a,b,c,...}}`\r\n *\r\n * 1. tokenize默认为第二位(index = 1)\r\n * 2. 第一个位置必须是name且不会进行解析\r\n * 3. 可以通过设置tokenizePos进行不同位置的解析，为true则全部都解析，false等价于[1]\r\n * 3. 当tokenizePos超过一个时，会自动生成token: template_name_division\r\n * 4. 不属于tokenizePos的内容将会加入configData\r\n * 5. 模板名字请不要重复\r\n *\r\n * ## options\r\n *\r\n * ```ts\r\n * interface TemplatePluginOptions {\r\n *   markerBegin?: string // 匹配起始标识符 默认: {{\r\n *   markerEnd?: string // 匹配结束标识符 默认: }}\r\n *   markerDivision?: string // 配置项分割标识符 默认: {{\r\n *   useEqual?: boolean // 是否启用=判定，启用则支持语法: configKey1=abc => { configKey1: abc }\r\n *   useIndex?: boolean // 是否启用下标顺序判定，启用则支持语法: 1=abc 从1开始!!\r\n *   // => 1. 设置了configKeys=['configKey1'] => { configKey1: abc }\r\n *   // => 2. 没有设置configKeys => { '1': abc }\r\n *   configKeys?: configKey[] // 设置配置项选择值，便于数据读取\r\n *   // 需要注意conf字符串不能是数字，不能是: '100'\r\n *   // ['conf1', 'conf2'] 设置两个conf，其分别对应1和2\r\n *   // [['conf1-1', 'conf1-2'], 'conf2'] 设置两个conf，但是输入: conf1-2=abc\\1=abc\\abc => { 'conf1-1': abc },会以数组中第一个进行替换\r\n *   render?: (tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) => string 自定义渲染函数\r\n *   renderDivision?: (tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) => string 自定义分割渲染函数\r\n * }\r\n * ```\r\n *\r\n * @param md md\r\n * @param name 模板名字\r\n * @param options 配置项\r\n */\r\nexport default function templatePlugin(\r\n  md: MarkdownIt,\r\n  name: string | string[],\r\n  options?: TemplatePluginOptions\r\n) {\r\n  function renderDefault(tokens: Token[], idx: number, _options: Options, env: any, slf: Renderer) {\r\n    return slf.renderToken(tokens, idx, _options)\r\n  }\r\n\r\n  function renderDivisionDefault(\r\n    tokens: Token[],\r\n    idx: number,\r\n    _options: Options,\r\n    env: any,\r\n    slf: Renderer\r\n  ) {\r\n    return slf.renderToken(tokens, idx, _options)\r\n  }\r\n\r\n  options = options || {}\r\n\r\n  const defaultName = Array.isArray(name) ? name[0] : name\r\n  const namesSet = new Set(Array.isArray(name) ? name : [name])\r\n\r\n  const tokenizePos = options.tokenizePos || [1]\r\n\r\n  const markerBegin = options.markerBegin || '{{'\r\n  const markerEnd = options.markerEnd || '}}'\r\n  const markerDivision = options.markerDivision || '|'\r\n  //\r\n  // 为true则支持语法：config1 = xxx\r\n  //\r\n  const useEqual = options.useEqual || true\r\n  //\r\n  // 0 = xxx\r\n  // xxx\r\n  // ->\r\n  // 0: xxx\r\n  //\r\n  const useIndex = options.useIndex || false\r\n  //\r\n  // config keys\r\n  // 设置这个才能更好的使用 0=xxx\r\n  // 例如: 设置[\"color\"];md中写0=red\r\n  // 获得: { \"color\": \"red\" }\r\n  // 否则获得: { \"0\": \"red\" }\r\n  //\r\n  const configKeys = options.configKeys || []\r\n  //\r\n  // 配置映射关系\r\n  //\r\n  const confMap = buildConfMap(configKeys)\r\n\r\n  const render = options.render || renderDefault\r\n\r\n  const renderDivision = options.renderDivision || renderDivisionDefault\r\n\r\n  function buildConfMap(configKeys: ConfigKey[]) {\r\n    const map = new Map<string, string>()\r\n    configKeys.forEach((conf) => {\r\n      if (Array.isArray(conf)) {\r\n        const base = conf[0]\r\n        conf.forEach((c) => {\r\n          map.set(base, c)\r\n        })\r\n      } else {\r\n        map.set(conf, conf)\r\n      }\r\n    })\r\n    return map\r\n  }\r\n\r\n  /**\r\n   * 找结束位置\r\n   * @param state\r\n   * @returns\r\n   */\r\n  function findEnd(state: StateInline): FindEndRes {\r\n    const max = state.posMax\r\n    let pos = state.pos + markerBegin.length\r\n    let level = 0\r\n    let lastDivisionPos = pos\r\n    const divisionDataList: any[] = []\r\n    while (pos < max) {\r\n      if (markerBegin === state.src.slice(pos, pos + markerBegin.length)) {\r\n        level++\r\n      } else if (markerEnd === state.src.slice(pos, pos + markerEnd.length)) {\r\n        if (level === 0) {\r\n          divisionDataList.push({\r\n            begin: lastDivisionPos,\r\n            end: pos\r\n          })\r\n          return {\r\n            check: true,\r\n            pos,\r\n            divisionDataList\r\n          }\r\n        } else level--\r\n      } else if (markerDivision === state.src.slice(pos, pos + markerDivision.length)) {\r\n        if (level === 0) {\r\n          divisionDataList.push({\r\n            begin: lastDivisionPos,\r\n            end: pos\r\n          })\r\n          lastDivisionPos = pos + 1\r\n        }\r\n      }\r\n      pos++\r\n    }\r\n    return {\r\n      check: false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 解析配置项\r\n   * @param config\r\n   * @param configs\r\n   * @param i\r\n   * @returns\r\n   */\r\n  function analyseConfig(config: string, configs: ConfigsDict, i: number) {\r\n    // console.log('analyseConfig', config, i)\r\n    const equalRegexp = /(?<!\\\\)=/g\r\n    const commaRegexp = /(?<!\\\\),/g\r\n\r\n    const equalRes = equalRegexp.exec(config)\r\n    equalRegexp.lastIndex = 0\r\n    const equalIndex = equalRes === null ? -1 : equalRes.index\r\n    const key = equalIndex === -1 ? i.toString() : config.slice(0, equalIndex).trim()\r\n    const value_ = equalIndex === -1 ? config : config.slice(equalIndex + 1).trim()\r\n    const value: any[] = []\r\n    let commaRes = commaRegexp.exec(value_)\r\n    let from = 0\r\n    while (commaRes !== null) {\r\n      value.push(value_.slice(from, commaRes.index).trim())\r\n      from = commaRes.index + 1\r\n      commaRes = commaRegexp.exec(value_)\r\n    }\r\n    value.push(value_.slice(from).trim())\r\n    commaRegexp.lastIndex = 0\r\n    //\r\n    // 允许使用=语法，且获取到=，且不是0=xxx的情况\r\n    //\r\n    if (useEqual && equalIndex !== -1 && Number.isNaN(Number(key))) {\r\n      //\r\n      // 找到该conf对应的conf\r\n      //\r\n      const trueKey = confMap.get(key)\r\n      if (trueKey === undefined) {\r\n        //\r\n        // 匹配失败不生效\r\n        //\r\n        return\r\n      } else {\r\n        configs[trueKey] = value\r\n        return\r\n      }\r\n    }\r\n    //\r\n    // 允许使用0=和直接下标映射语法，且key是数字\r\n    //\r\n    if (useIndex && !Number.isNaN(Number(key))) {\r\n      const index = Number(key)\r\n      if (configKeys[index] !== undefined) {\r\n        if (Array.isArray(configKeys[index])) {\r\n          configs[configKeys[index][0]] = value\r\n        } else {\r\n          configs[configKeys[index]] = value\r\n        }\r\n      } else {\r\n        configs[key] = value\r\n      }\r\n      return\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 插件核心\r\n   * @param state\r\n   * @param slient\r\n   * @returns\r\n   */\r\n  function template(state: StateInline, slient: boolean) {\r\n    const max = state.posMax // src长度\r\n    const start = state.pos\r\n\r\n    if (markerBegin !== state.src.slice(start, start + markerBegin.length)) {\r\n      return false\r\n    }\r\n    //\r\n    // 找结束\r\n    // posEnd指向结束符号开始的位置\r\n    // }}\r\n    // ⬆\r\n    //\r\n    const endRes = findEnd(state)\r\n\r\n    if (!endRes.check) {\r\n      return false\r\n    }\r\n    //\r\n    // check为true下面都存在\r\n    //\r\n    const end = endRes.pos as number\r\n    const divisionDataList = endRes.divisionDataList as DivisionData[]\r\n\r\n    if (\r\n      divisionDataList.length < 1 ||\r\n      !namesSet.has(state.src.slice(divisionDataList[0].begin, divisionDataList[0].end).trim())\r\n    ) {\r\n      return false\r\n    }\r\n    //\r\n    // found\r\n    //\r\n    const tStart = start + markerBegin.length\r\n    const tEnd = end\r\n\r\n    const configs = {}\r\n\r\n    let tokenizeAmount = 0\r\n\r\n    if (!slient) {\r\n      state.pos = tStart\r\n      state.posMax = tEnd\r\n\r\n      const token_o = state.push('template_' + defaultName + '_open', 'span', 1)\r\n\r\n      let configIndex = 0\r\n\r\n      divisionDataList.forEach((data, i) => {\r\n        if (i === 0) return\r\n        state.pos = data.begin\r\n        state.posMax = data.end\r\n        if (tokenizePos === true || (Array.isArray(tokenizePos) && tokenizePos.indexOf(i) !== -1)) {\r\n          if (tokenizeAmount > 0) state.push('template_' + defaultName + '_division', '', 0)\r\n          state.md.inline.tokenize(state)\r\n          tokenizeAmount++\r\n        } else {\r\n          analyseConfig(state.src.slice(data.begin, data.end), configs, configIndex++)\r\n        }\r\n      })\r\n\r\n      token_o.meta = {\r\n        configs\r\n      }\r\n\r\n      state.push('template_' + defaultName + '_close', 'span', -1)\r\n    }\r\n\r\n    state.pos = end + markerEnd.length\r\n    state.posMax = max\r\n    return true\r\n  }\r\n\r\n  md.inline.ruler.after('emphasis', 'template_' + defaultName, template)\r\n\r\n  md.renderer.rules['template_' + defaultName + '_open'] = render\r\n  md.renderer.rules['template_' + defaultName + '_close'] = render\r\n  md.renderer.rules['template_' + defaultName + '_division'] = renderDivision\r\n}\r\n"
  },
  {
    "name": "TemplateForTest.ts",
    "code": "import type MarkdownIt from 'markdown-it'\r\nimport templatePlugin from './template.ts'\r\nimport type Token from 'markdown-it/lib/token.mjs'\r\n\r\nfunction initTemplateTestPlugin1(md: MarkdownIt) {\r\n  md.use(templatePlugin, 'template-name-1', {\r\n    configKeys: ['type'],\r\n    render: function (tokens: Token[], idx: number) {\r\n      const token = tokens[idx]\r\n      const colorDict: Record<string, string> = {\r\n        default: 'transparent',\r\n        warning: '#F56C6C',\r\n        success: '#67C23A'\r\n      }\r\n      if (token.nesting === 1) {\r\n      // opening tag\r\n        const configs = token.meta.configs\r\n        // 用户配置项\r\n        console.log('template-name-1 configs', configs)\r\n        const colorType = (configs['type'] && configs['type'][0]) || 'default'\r\n        const color = colorDict[colorType.trim()] || colorType.trim()\r\n        const style = `background-color: ${color};`\r\n        return `<span style=\"${style}\">`\r\n      } else {\r\n      // closing tag\r\n        return '</span>'\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction initTemplateTestPlugin2(md: MarkdownIt) {\r\n  md.use(templatePlugin, 'template-name-2', {\r\n    configKeys: ['chars', 'color'],\r\n    render: function (tokens: Token[], idx: number) {\r\n      const token = tokens[idx]\r\n      if (token.nesting === 1) {\r\n      // opening tag\r\n        const configs = token.meta.configs\r\n        console.log('template-name-2 configs', configs)\r\n        const charsConf = (configs['chars']) || []\r\n        const color = (configs['color']) || ''\r\n        const chars = charsConf.join('-')\r\n        return `<span style=\"color: ${color}\">${chars}`\r\n      } else {\r\n      // closing tag\r\n        return '</span>'\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction initTemplateTestPlugin3(md: MarkdownIt) {\r\n  md.use(templatePlugin, 'template-name-3', {\r\n    configKeys: ['chars', 'color'],\r\n    useIndex: true,\r\n    render: function (tokens: Token[], idx: number) {\r\n      const token = tokens[idx]\r\n      if (token.nesting === 1) {\r\n      // opening tag\r\n        const configs = token.meta.configs\r\n        console.log('template-name-3 configs', configs)\r\n        const charsConf = (configs['chars']) || []\r\n        const color = (configs['color']) || ''\r\n        const chars = charsConf.join('-')\r\n        return `<span style=\"color: ${color}\">${chars}`\r\n      } else {\r\n      // closing tag\r\n        return '</span>'\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction initTemplateTestPlugin4(md: MarkdownIt) {\r\n  md.use(templatePlugin, 'template-name-4', {\r\n    configKeys: ['chars', 'color'],\r\n    tokenizePos: [], // 全部禁止解析\r\n    useIndex: true,\r\n    render: function (tokens: Token[], idx: number) {\r\n      const token = tokens[idx]\r\n      if (token.nesting === 1) {\r\n      // opening tag\r\n        const configs = token.meta.configs\r\n        console.log('template-name-4 configs', configs)\r\n        const charsConf = (configs['chars']) || []\r\n        const color = (configs['color']) || ''\r\n        const chars = charsConf.join('-')\r\n        return `<span style=\"color: ${color}\">${chars}`\r\n      } else {\r\n      // closing tag\r\n        return '</span>'\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport default [\r\n  initTemplateTestPlugin1,\r\n  initTemplateTestPlugin2,\r\n  initTemplateTestPlugin3,\r\n  initTemplateTestPlugin4\r\n]\r\n"
  }
]