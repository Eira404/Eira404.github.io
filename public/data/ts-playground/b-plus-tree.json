[
  {
    "name": "index.ts",
    "code": "import { print, printLeaf } from './utils.ts'\r\nimport { BPlusTree } from './tree.ts'\r\n\r\ntype item = {\r\n  id: number\r\n  value: string\r\n}\r\n\r\nconst tree = new BPlusTree<item>(3)\r\n// 5,6,4,8,7,10,36,16\r\ntree.insert(5, { id: 5, value: '5' })\r\ntree.insert(6, { id: 6, value: '6' })\r\ntree.insert(4, { id: 4, value: '4' })\r\ntree.insert(8, { id: 8, value: '8' })\r\ntree.insert(7, { id: 7, value: '7' })\r\ntree.insert(10, { id: 10, value: '10' })\r\ntree.insert(36, { id: 36, value: '36' })\r\ntree.insert(16, { id: 16, value: '16' })\r\n// console.log(tree)\r\nprint(tree)\r\nprintLeaf(tree)\r\n"
  },
  {
    "name": "leaf.ts",
    "code": "import type { BPlusTree } from './tree.ts'\r\nimport type { BPlusTreeNode } from './node.ts'\r\nimport { BPlusTreeValueNode } from './value.ts'\r\n\r\nexport class BPlusTreeLeafNode<V extends { id: string | number}> {\r\n  type = 'LEAF'\r\n  private __maxNodeCount: number\r\n  keys: number[] = []\r\n  values: BPlusTreeValueNode<V>[] = []\r\n  prev: null | BPlusTreeLeafNode<V> = null\r\n  next: null | BPlusTreeLeafNode<V> = null\r\n\r\n  get canRemove() {\r\n    return this.keys.length > (this.__maxNodeCount + 1) >> 1\r\n  }\r\n\r\n  constructor(maxNodeCount: number, entries?: [number[], BPlusTreeValueNode<V>[]]) {\r\n    this.__maxNodeCount = maxNodeCount\r\n    if (entries) {\r\n      this.keys = entries[0]\r\n      this.values = entries[1]\r\n    }\r\n  }\r\n\r\n  getFirstLeaf(): BPlusTreeLeafNode<V> {\r\n    return this\r\n  }\r\n\r\n  maxKey(): number {\r\n    return this.keys[this.keys.length - 1]\r\n  }\r\n\r\n  insert(key: number, value: V, bptree: BPlusTree<V>): BPlusTreeLeafNode<V> | boolean {\r\n    const keyI = this.keys.findIndex(item => key === item)\r\n    let ins\r\n    /** 数据不存在 */\r\n    if (keyI === -1) {\r\n      ins = new BPlusTreeValueNode<V>()\r\n      /** 查询插入位置 */\r\n      const tindex = this.keys.findIndex(item => item >= key)\r\n      const index = tindex === -1 ? this.keys.length : tindex\r\n      this.keys.splice(index, 0, key)\r\n      this.values.splice(index, 0, ins)\r\n    } else {\r\n      ins = this.values[keyI]\r\n    }\r\n    /** 插入数据 */\r\n    ins.insert(value)\r\n    /** 检查长度 */\r\n    const length = this.keys.length\r\n    if (length > this.__maxNodeCount) {\r\n      const center = length >> 1\r\n      const newKeys = this.keys.slice(center)\r\n      const newValues = this.values.slice(center)\r\n      this.keys =  this.keys.slice(0, center)\r\n      this.values =  this.values.slice(0, center)\r\n      const newNode = new BPlusTreeLeafNode(this.__maxNodeCount, [newKeys, newValues])\r\n      newNode.next = this.next\r\n      if (this.next) this.next.prev = newNode\r\n      this.next = newNode\r\n      newNode.prev = this\r\n      /** 返回右侧节点 */\r\n      return newNode\r\n    }\r\n    return true\r\n  }\r\n\r\n  remove(key: number, value: V, bpnode?: BPlusTreeNode<V>, i?: number): boolean {\r\n    const keyI = this.keys.findIndex(item => key === item)\r\n    if (keyI === -1) return false\r\n    const ins = this.values[keyI]\r\n    const res = ins.remove(value)\r\n    if (!res) return res\r\n    /** 如果value已经空，则移除value */\r\n    if (ins.size === 0) {\r\n      this.keys.splice(keyI, 1)\r\n      this.values.splice(keyI, 1)\r\n    }\r\n    if (bpnode === undefined || i === undefined) return true\r\n    /** 检查长度 */\r\n    const length = this.keys.length\r\n    /** 如果小于此，则检查是否可以合并 */\r\n    if (length <= ((this.__maxNodeCount + 1) >> 1) - 1) {\r\n      /** 检查前一个 */\r\n      if (i > 0) {\r\n        const prev = bpnode.values[i - 1] as BPlusTreeLeafNode<V>\r\n        /** 可以借最大的 */\r\n        if (prev.canRemove) {\r\n          const pkey = prev.keys[prev.keys.length - 1]\r\n          const pvalue = prev.values[prev.keys.length - 1]\r\n          prev.keys.length = prev.keys.length - 1\r\n          prev.values.length = prev.values.length - 1\r\n          this.keys.unshift(pkey)\r\n          this.values.unshift(pvalue)\r\n          bpnode.keys[i - 1] = bpnode.values[i - 1].maxKey()\r\n          return true\r\n        }\r\n      }\r\n      /** 检查后一个 */\r\n      if (i < bpnode.keys.length - 1) {\r\n        const next = bpnode.values[i + 1] as BPlusTreeLeafNode<V>\r\n        /** 可以借最小的 */\r\n        if (next.canRemove) {\r\n          const nkey = next.keys[0]\r\n          const nvalue = next.values[0]\r\n          next.keys = next.keys.slice(1)\r\n          next.values = next.values.slice(1)\r\n          this.keys.push(nkey)\r\n          this.values.push(nvalue)\r\n          bpnode.keys[i] = bpnode.values[i].maxKey()\r\n          return true\r\n        }\r\n      }\r\n      /** 都不可以借，只能进行合并 */\r\n      if (i > 0) {\r\n        /** 合并到左边 */\r\n        const prev = bpnode.values[i - 1] as BPlusTreeLeafNode<V>\r\n        prev.keys = prev.keys.concat(this.keys)\r\n        prev.values = prev.values.concat(this.values)\r\n        prev.next = this.next\r\n        if (this.next) this.next.prev = prev\r\n        bpnode.keys[i - 1] = bpnode.values[i - 1].maxKey()\r\n      } else {\r\n        /** 合并到右边 */\r\n        const next = bpnode.values[i + 1] as BPlusTreeLeafNode<V>\r\n        next.keys = this.keys.concat(next.keys)\r\n        next.values = this.values.concat(next.values)\r\n        next.prev = this.prev\r\n        if (this.prev) this.prev.next = next\r\n        bpnode.keys[i + 1] = bpnode.values[i + 1].maxKey()\r\n      }\r\n      /** 从父节点删除该节点 */\r\n      bpnode.keys.splice(i, 1)\r\n      bpnode.values.splice(i, 1)\r\n      return true\r\n    }\r\n    bpnode.keys[i] = bpnode.values[i].maxKey()\r\n    return res\r\n  }\r\n\r\n  search(key: number): BPlusTreeValueNode<V> | undefined {\r\n    const keyI = this.keys.findIndex(item => item === key)\r\n    if (keyI !== -1) return this.values[keyI]\r\n    return undefined\r\n  }\r\n\r\n  searchFirstBigger(key: number): BPlusTreeLeafNode<V> | undefined {\r\n    return this\r\n  }\r\n\r\n  getBigger(key: number): BPlusTreeValueNode<V>[] {\r\n    const keyI = this.keys.findIndex(item => item >= key)\r\n    if (keyI !== -1) return this.values.slice(keyI)\r\n    return this.values\r\n  }\r\n}\r\n"
  },
  {
    "name": "node.ts",
    "code": "import type { BPlusTree } from './tree.ts'\r\nimport { BPlusTreeLeafNode } from './leaf.ts'\r\nimport { BPlusTreeValueNode } from './value.ts'\r\n\r\nexport class BPlusTreeNode<V extends { id: string | number}> {\r\n  type = 'NODE'\r\n  private __maxNodeCount: number\r\n  keys: number[] = []\r\n  values: (BPlusTreeNode<V> | BPlusTreeLeafNode<V>)[] = []\r\n\r\n  get canRemove() {\r\n    return this.keys.length > (this.__maxNodeCount + 1) >> 1\r\n  }\r\n\r\n  constructor(maxNodeCount: number, entries?: [number[], (BPlusTreeNode<V> | BPlusTreeLeafNode<V>)[]]) {\r\n    this.__maxNodeCount = maxNodeCount\r\n    if (entries) {\r\n      this.keys = entries[0]\r\n      this.values = entries[1]\r\n    }\r\n  }\r\n\r\n  getFirstLeaf(): BPlusTreeLeafNode<V> {\r\n    const value = this.values[0]\r\n    if (value instanceof BPlusTreeLeafNode) {\r\n      return value\r\n    } else {\r\n      return value.getFirstLeaf()\r\n    }\r\n  }\r\n\r\n  maxKey(): number {\r\n    return this.keys[this.keys.length - 1]\r\n  }\r\n\r\n  insert(key: number, value: V, bptree: BPlusTree<V>): BPlusTreeNode<V> | boolean {\r\n    const keyI = this.keys.findIndex(item => item >= key)\r\n    let res\r\n    let node\r\n    /** 不存在比key大的数据 */\r\n    if (keyI === -1) {\r\n      node = this.values[this.values.length - 1]\r\n      res = node.insert(key, value, bptree)\r\n      this.keys[this.values.length - 1] = node.maxKey()\r\n    } else {\r\n      node = this.values[keyI]\r\n      res = node.insert(key, value, bptree)\r\n      this.keys[keyI] = node.maxKey()\r\n    }\r\n    if (typeof res === 'boolean') return res\r\n    /** 子进行了split，这里需要增加节点 */\r\n    const splicePos = keyI === -1 ? this.keys.length : keyI + 1\r\n    this.keys.splice(splicePos, 0, res.maxKey())\r\n    this.values.splice(splicePos, 0, res)\r\n    if (splicePos > 0 && this.values[splicePos - 1] instanceof BPlusTreeLeafNode && res instanceof BPlusTreeLeafNode) {\r\n      /** 如果前一个节点也是叶子节点，则将前一个节点的next指向当前节点 */\r\n      (this.values[splicePos - 1] as BPlusTreeLeafNode<V>).next = res\r\n      res.prev = this.values[splicePos - 1] as BPlusTreeLeafNode<V>\r\n    } else if (splicePos < this.keys.length - 1 && this.values[splicePos + 1] instanceof BPlusTreeLeafNode && res instanceof BPlusTreeLeafNode) {\r\n      /** 如果后一个节点也是叶子节点，则将当前节点的next指向后一个节点 */\r\n      res.next = (this.values[splicePos + 1] as BPlusTreeLeafNode<V>);\r\n      (this.values[splicePos + 1] as BPlusTreeLeafNode<V>).prev = res\r\n    } else if (splicePos === this.keys.length && res instanceof BPlusTreeLeafNode) {\r\n      /** 是最后一个节点 */\r\n      res.next = null\r\n    } else if (splicePos === 0 && res instanceof BPlusTreeLeafNode) {\r\n      res.prev = null\r\n    }\r\n    /** 检查长度 */\r\n    const length = this.keys.length\r\n    if (length > this.__maxNodeCount) {\r\n      const center = length >> 1\r\n      const newKeys = this.keys.slice(center)\r\n      const newValues = this.values.slice(center)\r\n      this.keys =  this.keys.slice(0, center)\r\n      this.values = this.values.slice(0, center)\r\n      const newNode = new BPlusTreeNode(this.__maxNodeCount, [newKeys, newValues])\r\n      /** 返回右侧节点 */\r\n      return newNode\r\n    }\r\n    return true\r\n  }\r\n\r\n  remove(key: number, value: V, bpnode?: BPlusTreeNode<V>, i?: number): boolean {\r\n    const keyI = this.keys.findIndex(item => item >= key)\r\n    if (keyI === -1) return false\r\n    const ins = this.values[keyI]\r\n    const res = ins.remove(key, value, this, keyI)\r\n    if (!res) return res\r\n    if (bpnode === undefined || i === undefined) return true\r\n    /** 检查长度 */\r\n    const length = this.keys.length\r\n    /** 如果小于此，则检查是否可以合并 */\r\n    if (length <= ((this.__maxNodeCount + 1) >> 1) - 1) {\r\n      /** 检查前一个 */\r\n      if (i > 0) {\r\n        const prev = bpnode.values[i - 1] as BPlusTreeNode<V>\r\n        /** 可以借最大的 */\r\n        if (prev.canRemove) {\r\n          const pkey = prev.keys[prev.keys.length - 1]\r\n          const pvalue = prev.values[prev.keys.length - 1]\r\n          prev.keys.length = prev.keys.length - 1\r\n          prev.values.length = prev.values.length - 1\r\n          this.keys.unshift(pkey)\r\n          this.values.unshift(pvalue)\r\n          bpnode.keys[i - 1] = bpnode.values[i - 1].maxKey()\r\n          return true\r\n        }\r\n      }\r\n      /** 检查后一个 */\r\n      if (i < bpnode.keys.length - 1) {\r\n        const next = bpnode.values[i + 1] as BPlusTreeNode<V>\r\n        /** 可以借最小的 */\r\n        if (next.canRemove) {\r\n          const nkey = next.keys[0]\r\n          const nvalue = next.values[0]\r\n          next.keys = next.keys.slice(1)\r\n          next.values = next.values.slice(1)\r\n          this.keys.push(nkey)\r\n          this.values.push(nvalue)\r\n          bpnode.keys[i] = bpnode.values[i].maxKey()\r\n          return true\r\n        }\r\n      }\r\n      /** 都不可以借，只能进行合并 */\r\n      if (i > 0) {\r\n        /** 合并到左边 */\r\n        const prev = bpnode.values[i - 1] as BPlusTreeNode<V>\r\n        prev.keys = prev.keys.concat(this.keys)\r\n        prev.values = prev.values.concat(this.values)\r\n        bpnode.keys[i - 1] = bpnode.values[i - 1].maxKey()\r\n      } else {\r\n        /** 合并到右边 */\r\n        const next = bpnode.values[i + 1] as BPlusTreeNode<V>\r\n        next.keys = this.keys.concat(next.keys)\r\n        next.values = this.values.concat(next.values)\r\n        bpnode.keys[i + 1] = bpnode.values[i + 1].maxKey()\r\n      }\r\n      /** 从父节点删除该节点 */\r\n      bpnode.keys.splice(i, 1)\r\n      bpnode.values.splice(i, 1)\r\n      return true\r\n    }\r\n    bpnode.keys[i] = bpnode.values[i].maxKey()\r\n    return res\r\n  }\r\n\r\n  getPrevAndNext(key: number) {\r\n    const i = this.keys.findIndex(item => item === key)\r\n    return [i - 1, i + 1]\r\n  }\r\n\r\n  search(key: number): BPlusTreeValueNode<V> | undefined {\r\n    const keyI = this.keys.findIndex(item => item >= key)\r\n    if (keyI !== -1) return this.values[keyI].search(key)\r\n    return undefined\r\n  }\r\n\r\n  searchFirstBigger(key: number): BPlusTreeLeafNode<V> | undefined {\r\n    const keyI = this.keys.findIndex(item => item >= key)\r\n    if (keyI !== -1 && this.values[keyI] instanceof BPlusTreeLeafNode) return this.values[keyI]\r\n    if (keyI !== -1 && this.values[keyI] instanceof BPlusTreeNode) return this.values[keyI].searchFirstBigger(key)\r\n    return undefined\r\n  }\r\n}\r\n"
  },
  {
    "name": "tree.ts",
    "code": "import { BPlusTreeLeafNode } from './leaf.ts'\r\nimport { BPlusTreeNode } from './node.ts'\r\nimport { BPlusTreeValueNode } from './value.ts'\r\n\r\nexport class BPlusTree<V extends { id: string | number}> {\r\n  private __root: BPlusTreeNode<V> | BPlusTreeLeafNode<V> | null = null\r\n  private __maxNodeCount: number = 32\r\n  get root() {\r\n    return this.__root\r\n  }\r\n\r\n  constructor(maxNodeCount: number = 32) {\r\n    this.__maxNodeCount = Math.max(3, maxNodeCount)\r\n  }\r\n\r\n  clear() {\r\n    this.__root = null\r\n  }\r\n\r\n  getFirstLeaf(): BPlusTreeLeafNode<V> | null {\r\n    return this.__root?.getFirstLeaf() ?? null\r\n  }\r\n\r\n  insert(key: number, value: V) {\r\n    if (this.__root === null) {\r\n      this.__root = new BPlusTreeLeafNode(this.__maxNodeCount)\r\n    }\r\n    const res = this.__root.insert(key, value, this)\r\n    if (typeof res === 'boolean') return res\r\n    this.__root = new BPlusTreeNode(this.__maxNodeCount, [[this.__root.maxKey(), res.maxKey()], [this.__root, res]])\r\n    return true\r\n  }\r\n\r\n  remove(key: number, value: V): boolean {\r\n    if (this.__root === null) return false\r\n    const res = this.__root.remove(key, value)\r\n    if (this.__root.values.length === 1 && !(this.__root.values[0] instanceof BPlusTreeValueNode)) this.__root = this.__root.values[0]\r\n    return res\r\n  }\r\n\r\n  search(key: number): BPlusTreeValueNode<V> | undefined {\r\n    if (this.__root) return this.__root.search(key)\r\n    return undefined\r\n  }\r\n\r\n  searchFirstBigger(key: number): BPlusTreeLeafNode<V> | undefined {\r\n    if (this.__root) return this.__root.searchFirstBigger(key)\r\n    return undefined\r\n  }\r\n}\r\n"
  },
  {
    "name": "utils.ts",
    "code": "import { BPlusTreeLeafNode } from './leaf.ts'\r\nimport { BPlusTreeNode } from './node.ts'\r\nimport { BPlusTree } from './tree.ts'\r\nimport { BPlusTreeValueNode } from './value.ts'\r\n\r\nexport function print<V extends { id: string | number}>(tree: BPlusTree<V>) {\r\n  const root = tree.root\r\n  if (root === null) {\r\n    console.log('Empty tree')\r\n    return\r\n  }\r\n  let keysNums: number = root.keys.length\r\n  let tempKeysNums: number = 0\r\n  const keys: number[] = Array.from(root.keys)\r\n  const values: (BPlusTreeNode<V> | BPlusTreeLeafNode<V>)[] | BPlusTreeValueNode<V>[] = Array.from(root.values as any) as (BPlusTreeNode<V> | BPlusTreeLeafNode<V>)[] | BPlusTreeValueNode<V>[]\r\n  let tempConsole = ''\r\n  console.log('<------------------- Tree Begin ------------------->')\r\n  while (values.length > 0) {\r\n    keysNums--\r\n    const k = keys.shift()!\r\n    const v = values.shift()!\r\n    if (v instanceof BPlusTreeValueNode) {\r\n      tempConsole += ` ${k} `\r\n    } else {\r\n      keys.push(...Array.from(v.keys))\r\n      const vl = v.values\r\n      values.push(...Array.from(vl as any) as any)\r\n      tempKeysNums += v.keys.length\r\n      tempConsole += ` ${k} -> ${JSON.stringify(v.keys)} `\r\n    }\r\n    if (keysNums === 0) {\r\n      console.log(tempConsole)\r\n      tempConsole = ''\r\n      keysNums = tempKeysNums\r\n      tempKeysNums = 0\r\n    }\r\n  }\r\n  console.log('<------------------- Tree End ------------------->')\r\n}\r\n\r\nexport function printLeaf<V extends { id: string | number}>(tree: BPlusTree<V>) {\r\n  let leaf = tree.getFirstLeaf()\r\n  let res = ''\r\n  let t = 0\r\n  while (leaf !== null && t++ < 20) {\r\n    const keys = Array.from(leaf.keys)\r\n    res += '< '\r\n    keys.forEach((k, i) => {\r\n      res += `${k} `\r\n    })\r\n    res += '> '\r\n    leaf = leaf.next\r\n  }\r\n  console.log(res)\r\n}\r\n"
  },
  {
    "name": "value.ts",
    "code": "export class BPlusTreeValueNode<V extends { id: string | number}> {\r\n  private __values: Map<string | number, V> = new Map()\r\n\r\n  get size() {\r\n    return this.__values.size\r\n  }\r\n\r\n  values() {\r\n    return this.__values.values()\r\n  }\r\n\r\n  insert(value: V) {\r\n    this.__values.set(value.id, value)\r\n  }\r\n\r\n  remove(value: V) {\r\n    return this.__values.delete(value.id)\r\n  }\r\n}\r\n"
  }
]